generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id                 Int               @id @default(autoincrement())
  email              String            @unique
  passwordHash       String?           @map("password_hash")
  name               String
  characterImage     String?           @map("character_image_url")
  points             Int               @default(1000)
  nickname           String?           @unique
  kakaoId            String?           @unique @map("kakao_id")
  googleId           String?           @unique @map("google_id")
  refreshToken       String?           @map("refresh_token")
  createdAt          DateTime          @default(now()) @map("created_at")
  updatedAt          DateTime          @updatedAt @map("updated_at")
  matchLineups       MatchLineup[]
  predictions        Prediction[]
  tactics            Tactic[]
  joinRequests       TeamJoinRequest[]
  teamMemberships    TeamMember[]
  managedTournaments Tournament[]
  profiles           UserProfile[]

  @@map("users")
}

model UserProfile {
  id            Int      @id @default(autoincrement())
  userId        Int      @map("user_id")
  sportType     String   @map("sport_type")
  position      String?
  tier          String?
  champions     String?
  preferredFoot String?  @map("preferred_foot")
  height        String?
  introduction  String?  @db.Text
  createdAt     DateTime @default(now()) @map("created_at")
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, sportType])
  @@map("user_profiles")
}

model Team {
  id                     Int               @id @default(autoincrement())
  name                   String
  sport                  String
  sportType              String            @map("sport_type")
  inviteCode             String            @unique @map("invite_code")
  description            String?           @db.Text
  wins                   Int               @default(0)
  losses                 Int               @default(0)
  matchCount             Int               @default(0) @map("match_count")
  representativeTacticId Int?              @map("representative_tactic_id")
  createdAt              DateTime          @default(now()) @map("created_at")
  updatedAt              DateTime          @updatedAt @map("updated_at")
  lineups                MatchLineup[]
  homeMatches            Match[]           @relation("TeamA")
  awayMatches            Match[]           @relation("TeamB")
  wonMatches             Match[]           @relation("WinnerTeam")
  predictedIn            Prediction[]
  tactics                Tactic[]
  joinRequests           TeamJoinRequest[]
  members                TeamMember[]
  representativeTactic   Tactic?           @relation("TeamRepresentative", fields: [representativeTacticId], references: [id])
  tournamentTeams        TournamentTeam[]
  wonTournaments         Tournament[]

  @@index([representativeTacticId], map: "teams_representative_tactic_id_fkey")
  @@map("teams")
}

model TeamMember {
  id       Int      @id @default(autoincrement())
  teamId   Int      @map("team_id")
  userId   Int      @map("user_id")
  role     String
  position String?
  joinedAt DateTime @default(now()) @map("joined_at")
  team     Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@index([userId], map: "team_members_user_id_fkey")
  @@map("team_members")
}

model TeamJoinRequest {
  id          Int       @id @default(autoincrement())
  teamId      Int       @map("team_id")
  userId      Int       @map("user_id")
  position    String?
  status      String    @default("pending")
  appliedAt   DateTime  @default(now()) @map("applied_at")
  processedAt DateTime? @map("processed_at")
  team        Team      @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@index([userId], map: "team_join_requests_user_id_fkey")
  @@map("team_join_requests")
}

model Tournament {
  id                 Int              @id @default(autoincrement())
  name               String
  sport              String
  status             String
  isPrivate          Boolean          @default(false) @map("is_private")
  inviteCode         String?          @map("invite_code")
  description        String?          @db.Text
  managerId          Int?             @map("manager_id")
  winnerId           Int?             @map("winner_id")
  startDate          DateTime?        @map("start_date") @db.Date
  endDate            DateTime?        @map("end_date") @db.Date
  format             String           @default("TOURNAMENT")
  playoffTeams       Int?             @map("playoff_teams")
  createdAt          DateTime         @default(now()) @map("created_at")
  updatedAt          DateTime         @default(now()) @updatedAt @map("updated_at")
  bracketGeneration  String?          @map("bracket_generation")
  sportType          String           @default("lol") @map("sport_type")
  groupCount         Int?             @map("group_count")
  targetTeamCount    Int?             @map("target_team_count")
  matches            Match[]
  participatingTeams TournamentTeam[]
  manager            User?            @relation(fields: [managerId], references: [id])
  winner             Team?            @relation(fields: [winnerId], references: [id])

  @@index([managerId], map: "tournaments_manager_id_fkey")
  @@index([winnerId], map: "tournaments_winner_id_fkey")
  @@map("tournaments")
}

model TournamentTeam {
  id           Int        @id @default(autoincrement())
  tournamentId Int        @map("tournament_id")
  teamId       Int        @map("team_id")
  joinedAt     DateTime   @default(now()) @map("joined_at")
  status       String     @default("PENDING")
  team         Team       @relation(fields: [teamId], references: [id], onDelete: Cascade)
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@unique([tournamentId, teamId])
  @@index([teamId], map: "tournament_teams_team_id_fkey")
  @@map("tournament_teams")
}

model Match {
  id           Int             @id @default(autoincrement())
  tournamentId Int             @map("tournament_id")
  roundName    String?         @map("round_name")
  teamAId      Int?            @map("team_a_id")
  teamBId      Int?            @map("team_b_id")
  teamAScore   Int?            @map("team_a_score")
  teamBScore   Int?            @map("team_b_score")
  winnerTeamId Int?            @map("winner_team_id")
  status       String
  matchDate    DateTime?       @map("match_date")
  createdAt    DateTime        @default(now()) @map("created_at")
  updatedAt    DateTime        @default(now()) @updatedAt @map("updated_at")
  stage        String          @default("MAIN")
  lineups      MatchLineup[]
  teamA        Team?           @relation("TeamA", fields: [teamAId], references: [id])
  teamB        Team?           @relation("TeamB", fields: [teamBId], references: [id])
  tournament   Tournament      @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  winnerTeam   Team?           @relation("WinnerTeam", fields: [winnerTeamId], references: [id])
  stats        PredictionStat?
  predictions  Prediction[]

  @@index([teamAId], map: "matches_team_a_id_fkey")
  @@index([teamBId], map: "matches_team_b_id_fkey")
  @@index([tournamentId], map: "matches_tournament_id_fkey")
  @@index([winnerTeamId], map: "matches_winner_team_id_fkey")
  @@map("matches")
}

model MatchLineup {
  id        Int      @id @default(autoincrement())
  matchId   Int      @map("match_id")
  teamId    Int?     @map("team_id")
  userId    Int?     @map("user_id")
  position  String
  champion  String?
  createdAt DateTime @default(now()) @map("created_at")
  match     Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  team      Team?    @relation(fields: [teamId], references: [id])
  user      User?    @relation(fields: [userId], references: [id])

  @@index([matchId], map: "match_lineups_match_id_fkey")
  @@index([teamId], map: "match_lineups_team_id_fkey")
  @@index([userId], map: "match_lineups_user_id_fkey")
  @@map("match_lineups")
}

model Tactic {
  id               Int      @id @default(autoincrement())
  creatorId        Int?     @map("creator_id")
  teamId           Int?     @map("team_id")
  name             String
  boardType        String   @map("board_type")
  type             String?
  isPublic         Boolean  @default(false) @map("is_public")
  positions        Json
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @default(now()) @updatedAt @map("updated_at")
  creator          User?    @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  team             Team?    @relation(fields: [teamId], references: [id])
  representedTeams Team[]   @relation("TeamRepresentative")

  @@index([creatorId], map: "tactics_creator_id_fkey")
  @@index([teamId], map: "tactics_team_id_fkey")
  @@map("tactics")
}

model Prediction {
  id              Int      @id @default(autoincrement())
  userId          Int      @map("user_id")
  matchId         Int      @map("match_id")
  predictedTeamId Int      @map("predicted_team_id")
  betAmount       Int      @map("bet_amount")
  odds            Decimal? @db.Decimal(5, 2)
  status          String?  @default("pending")
  payout          Int?
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @default(now()) @updatedAt @map("updated_at")
  match           Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)
  predictedTeam   Team     @relation(fields: [predictedTeamId], references: [id])
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, matchId])
  @@index([matchId], map: "predictions_match_id_fkey")
  @@index([predictedTeamId], map: "predictions_predicted_team_id_fkey")
  @@map("predictions")
}

model PredictionStat {
  id              Int      @id @default(autoincrement())
  matchId         Int      @unique @map("match_id")
  totalVotes      Int      @default(0) @map("total_votes")
  totalPoints     Int      @default(0) @map("total_points")
  teamAPercentage Decimal? @default(0.00) @map("team_a_percentage") @db.Decimal(5, 2)
  teamBPercentage Decimal? @default(0.00) @map("team_b_percentage") @db.Decimal(5, 2)
  updatedAt       DateTime @default(now()) @updatedAt @map("updated_at")
  match           Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@map("prediction_stats")
}
